<!-- saved from url=(0028)http://ejohn.org/apps/learn/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Advanced JavaScript - Aidan Feldman</title>
<link rel="stylesheet" href="assets/deck.css">
<link rel="stylesheet" href="vendor/recipes.css">
<script src="vendor/jquery.js"></script>
<script src="vendor/jquery.chili.js"></script>
<script src="vendor/recipes.js"></script>
<script src="vendor/falafel.js"></script>
<script src="assets/deck.js"></script>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-19048260-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<h3 class="">Advanced JavaScript</h3>
<div id="area">
<pre id="pre" class="javascript">
</pre>
<form id="form">
<div class="buttons" style="display: none; ">
<input type="button" id="prev" value="<< Prev">
<input type="button" id="next" value="Next >>">
</div>
<div id="container">
	<p id="cite">Get the source code <a href="https://github.com/advanced-js/deck">here</a>.  Slides by <a href="http://afeld.me">Aidan Feldman</a>.  Template blatantly stolen from <a href="http://ejohn.org/apps/learn">John Resig</a>.</p>
</div>
</form>
</div>
<dl style="display: none; ">

	
		<dt>array_as_object.js</dt>
		<dd>
			<pre>var myAry = [
  'foo',
  'bar',
  'baz'
];

assertTripleEqual(myAry[0], 'foo', "access with number");
assertTripleEqual(myAry['0'], 'foo', "access with string");

assertTripleEqual(typeof {}, 'object', "an object is an Object");
assertTripleEqual(typeof myAry, 'object', "so is an Array");

myAry.newProp = "A property on an array";
assertTripleEqual(myAry.newProp, "A property on an array", "assigning arbitrary properties");
assertTripleEqual(myAry['newProp'], "A property on an array", "can retrieve properties with square brackets");
assertTripleEqual(myAry[0], 'foo', "array access still works");
</pre>
		</dd>
	
		<dt>object_literal.js</dt>
		<dd>
			<pre>var person1 = {
  first: 'Bob',
  last: 'Hope'
};
var person2 = person1;

person2.last = 'Marley';

assertTripleEqual(person1.last, 'Marley', "the original object is changed");
assertTripleEqual(person1, person2, "they are the same object");
</pre>
		</dd>
	
		<dt>pass_by_reference.js</dt>
		<dd>
			<pre>function increment(val){
  val += 1;
  return val;
}

var counter = 0;
var incVal = increment(counter);
assertTripleEqual(counter, 0, "primitives are pass-by-value");
assertTripleEqual(incVal, 1, "returns incremented value");


function reset(statusObj){
  statusObj.total = 0;
}

var myStatus = {
  total: 6
};
reset(myStatus);
assertTripleEqual(myStatus.total, 0, "objects are pass-by-reference");
</pre>
		</dd>
	
		<dt>arguments.js</dt>
		<dd>
			<pre>function argumentative(){
  assertTripleEqual(arguments instanceof Array, false, "'arguments' isn't really an array");
  assertTripleEqual(typeof arguments.join, 'undefined', "no join method on 'arguments'");

  assertTripleEqual(arguments.length, 3, "but 'arguments' do have 'length'");
}

argumentative('foo', 'bar', 'baz');
</pre>
		</dd>
	
		<dt>echo_exercise.js</dt>
		<dd>
			<pre>// see https://github.com/advanced-js/echo
</pre>
		</dd>
	
		<dt>extend.js</dt>
		<dd>
			<pre>function extend(dest /*, sources */){
  var source, attr;
  for (var i = 1; i < arguments.length; i++){
    source = arguments[i];
    for (attr in source){
      dest[attr] = source[attr];
    }
  }
}

var obj1 = {
  obj1Prop: true
};

var obj2 = {
  obj2Prop: true
};

extend(obj1, obj2);

assertDeepEqual(obj1, { obj1Prop: true, obj2Prop: true }, "merges properties onto destination");
assertDeepEqual(obj2, { obj2Prop: true }, "doesn't modify source object");
</pre>
		</dd>
	
		<dt>countdown_exercise.js</dt>
		<dd>
			<pre>// see https://github.com/advanced-js/countdown
</pre>
		</dd>
	
		<dt>event_loop.js</dt>
		<dd>
			<pre>// statements execute in order, except when there is a call that is asynchronous

var order = [];

order.push('before');

setTimeout(function(){
  order.push('within');

  assertDeepEqual(order, ['before', 'after', 'within'], "timeout callback executed last");
}, 0);

order.push('after');

// procedural statements executed in order, and async functions are queued in event loop
</pre>
		</dd>
	
		<dt>callbacks.js</dt>
		<dd>
			<pre>// fake jQuery
var $$ = {
  get: function(url, callback){
    // this is where the call to the server would happen

    // fake it with a timeout
    setTimeout(function(){
      callback({ status: 'ok' });
    }, 100);
  }
};

var callbackCalled = false;
$$.get('http://foo.com/bar.json', function(data){
  callbackCalled = true;
  assertTripleEqual(data.status, 'ok', "the callback receives the data");
});

assertTripleEqual(callbackCalled, false, "callback doesn't exectute immediately");
</pre>
		</dd>
	
		<dt>self_executing_functions.js</dt>
		<dd>
			<pre>// Fake jQuery: aQuery!

var aQueryCalled = false;

var aQuery = function(){
  aQueryCalled = true;
};

var $$ = function(){
  throw new Error("outer $$() should not be called");
};

// this technique is used for jQuery plugins, where there might be other libraries (e.g. Prototype) that use the dollar sign variable
(function($$){
  // $$ is assigned to the argument passed in, which supercedes the local variable above
  $$('foo');
  assertTripleEqual(aQueryCalled, true, "aQuery() should have been called");
})(aQuery);
</pre>
		</dd>
	
		<dt>this.js</dt>
		<dd>
			<pre>// NOTE: broken in the deck - run with `node scripts/run_tests.js examples/this.js`

var global = this; // 'window' in the browser


function fn1(){
  return this;
}

assertTripleEqual(fn1(), global, "functions defined globally have global context");
assertTripleEqual(global.fn1(), global, "functions defined globally are available on the global object");


// effectively the same as above
global.fn2 = function(){
  return this;
};

assertTripleEqual(global.fn2(), global, "functions defined on the glboal object have global context");
assertTripleEqual(fn2(), global, "the global object is inferred when no parent object is specified");


var obj = {
  fn3: function(){
    return this;
  }
};

assertTripleEqual(obj.fn3(), obj, "functions defined on an object have the context of that object");


var fn3 = obj.fn3;
assertTripleEqual(fn3(), global, "context is dependent on where the function is called, not where it's defined");

assertTripleEqual(fn3.call(obj), obj, "applied context modifies 'this'");
</pre>
		</dd>
	
		<dt>apply_context.js</dt>
		<dd>
			<pre>// NOTE: broken in the deck

var myVariable = "I'm global!";

function printMyVariable(){
  return this.myVariable;
}

// without additional arguments, apply() vs. call() are interchangeable
assertTripleEqual(printMyVariable(), "I'm global!", "without specifying context");
assertTripleEqual(printMyVariable.apply(null), "I'm global!", "using 'null' context");
assertTripleEqual(printMyVariable.apply(undefined), "I'm global!", "using 'undefined' context");
assertTripleEqual(printMyVariable.apply(this), "I'm global!", "using 'this' context");

assertTripleEqual(printMyVariable.apply({ myVariable: "I'm local!" }), "I'm local!", "using object as context");
</pre>
		</dd>
	
		<dt>call_vs_apply.js</dt>
		<dd>
			<pre>function title(first, last){
  return first + ' ' + last + ', M.D.';
}

assertTripleEqual(title.call(this, 'Michaela', 'Quinn'), 'Michaela Quinn, M.D.', "call() takes individual arguments after the context");
assertTripleEqual(title.apply(this, ['Michaela', 'Quinn']), 'Michaela Quinn, M.D.', "apply() takes individual arguments after the context");

// easy to remember - 'a' (in 'apply') is for Array
</pre>
		</dd>
	
		<dt>bind.js</dt>
		<dd>
			<pre>var obj = {
  first: 'Bob',
  last: 'Hope',
  fullName: function(){
    return this.first + ' ' + this.last;
  }
};

function bind(fn, context){
  return function(){
    return fn.apply(context, arguments);
  };
}

// alias the function
var unbound = obj.fullName;

assertTripleEqual(unbound(), 'undefined undefined', "without binding, function calls use the calling scope");

// bind it to the original context
var bound = bind(unbound, obj);

assertTripleEqual(typeof bound, 'function', "bind() returns a function");
assertTripleEqual(bound === unbound, false, "returns a new function");
assertTripleEqual(bound(), 'Bob Hope', "bound function will use the specified context");
assertTripleEqual(bound.call({}), 'Bob Hope', "bound function can be called in any context");
</pre>
		</dd>
	
		<dt>oop_basic.js</dt>
		<dd>
			<pre>var Person = function(first, last){
  this.first = first;
  this.last = last;
};

var bob = new Person('Bob', 'Hope');
var sally = new Person('Sally', 'Field');

assertTripleEqual(bob.first, 'Bob', "the public properties are accessible");

assertTripleEqual(bob === sally, false, "two instances are not the same");

assertTripleEqual(bob instanceof Person, true, "'new' creates instance");
assertTripleEqual(bob instanceof Object, true, "it's an Object");
</pre>
		</dd>
	
		<dt>instance_vs_prototype.js</dt>
		<dd>
			<pre>var Person = function(first, last){
  this.first = first;
  this.last = last;

  this.fullName = function(){
    return this.first + ' ' + this.last;
  };
};

Person.prototype.title = function(){
  return 'Mr. ' + this.fullName();
};

var bruce = new Person('Bruce', 'Wayne');
var tony = new Person('Tony', 'Stark');

assertTripleEqual(bruce.fullName(), 'Bruce Wayne', "correct fullName for bruce");
assertTripleEqual(tony.fullName(), 'Tony Stark', "correct fullName for tony");

assertTripleEqual(bruce.fullName === tony.fullName, false, "functions created in the constructor are unique to each instance");

assertTripleEqual(bruce.title(), 'Mr. Bruce Wayne', "correct title for bruce");
assertTripleEqual(tony.title(), 'Mr. Tony Stark', "correct title for tony");

assertTripleEqual(bruce.title, tony.title, "functions set on the prototype are shared by all instances");
</pre>
		</dd>
	
		<dt>object_prototype.js</dt>
		<dd>
			<pre>// remember array_as_object.js?
// native types have prototypes, too

var myAry = [];
var myObj = {};

assertTripleEqual(typeof myObj, 'object', "an object is an Object");
assertTripleEqual(typeof myAry, 'object', "so is an Array");

assertTripleEqual(Object.prototype.toString.apply(myObj), '[object Object]', "Object's toString() acts differently than typeof");
assertTripleEqual(Object.prototype.toString.apply(myAry), '[object Array]', "it can distinguish an Array from an Object");

// look at _.isArray()
// http://underscorejs.org/docs/underscore.html
</pre>
		</dd>
	
		<dt>oop_inheritance.js</dt>
		<dd>
			<pre>var Vehicle = function(){};

Vehicle.prototype.numWheels = function(){
  return undefined;
};

var Car = function(){};
// note this is an ES5 thing
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Browser_compatibility
Car.prototype = Object.create(Vehicle.prototype);

Car.prototype.numWheels = function(){
  return 4;
};

var myVehicle = new Vehicle();
var myCar = new Car();

assertTripleEqual(myCar.numWheels(), 4, "subclass used its own function definition");
assertTripleEqual(myVehicle.numWheels(), undefined, "superclass function wasn't overwritten");
</pre>
		</dd>
	
		<dt>namespace.js</dt>
		<dd>
			<pre>// like Java, but hackier!

// create the namespace
var app = {}; // the only global
app.models = {};

// add stuff to the namespace
app.models.User = function(){};
app.models.Vehicle = function(){};

// use stuff from the namespace
var bob = new app.models.User();

assertTripleEqual(bob instanceof Object, true, "Objects under a namespace are just Objects");

// perks:
// * helps to organize
// * doesn't crowd the global namespace
</pre>
		</dd>
	
		<dt>namespace_exercise.js</dt>
		<dd>
			<pre>// EXERCISE: write a namespace() function that takes a period-delimited
// string of arbitrary length and makes that namespace available globally,
// without squashing any that were previously-defined.  For example:

function namespace(path){
  // ...
}

namespace('app.models');
// creates `app.models`.  We can then add a Class to it:
//
//   app.models.User = function(){};

namespace('app.views');
// add a class to it:
//
//   app.views.User = function(){};
//   assertTripleEqual(app.models.User === app.views.User, false, "different namespaces don't override each other");

namespace('foo.lib.external');
// is synonymous to:
//
//   var foo = {};
//   foo.lib = {};
//   foo.lib.external = {};

// Build it using TDD!
// https://github.com/advanced-js/syllabus#test-frameworks

// Level 1: Make it work for namespaces
//   of a certain length, e.g.
//   'app.models' and 'foo.lib'.
//
// Level 2: Make it work for namespaces
//   of arbitrary length.
//
// Level 3: If some level of the namespace
//   already exists, don't override it, e.g.
//
//   namespace('app.models');
//   app.models.View = function(){};
//
//   namespace('app.views');
//   app.models.View; // should not raise an error

// start here: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/split
</pre>
		</dd>
	
		<dt>oop_private.js</dt>
		<dd>
			<pre>var User = function(username, pass){
  var password = pass;
  this.username = username;

  this.login = function(checkPass){
    return checkPass === password;
  };
};

var tony = new User('tony', '12345');

assertTripleEqual(tony.pass, undefined, "the args aren't accessible");
assertTripleEqual(tony.password, undefined, "private properties aren't accessible");

assertTripleEqual(tony.login('foo'), false, "methods can access private vars");
assertTripleEqual(tony.login('12345'), true, "methods can access private vars, again");

// EXERCISE:
// create a Backbone-like model that has get() and set() methods that work for arbitrary attributes, e.g.
//
//   var bob = new User();
//   bob.set('phone', '123-456-7890');
//   var bobsPhone = bob.get('phone');
</pre>
		</dd>
	
		<dt>singleton.js</dt>
		<dd>
			<pre>// Fake jQuery
// Usage:
//   $$('#mySelector') // element
//   $$.cacheLength() // int (number of selectors in cache)

var $$ = function(selector){
  assertTripleEqual(this === $$, false, "'this' refers to the window/global");

  // check if it's already cached
  var elt = $$._elementCache[selector];
  if (!elt){
    elt = 'fakeElement'; // we would actually use document.getElementById(), etc.
    $$._elementCache[selector] = elt; // cache it
    $$._cacheSize++;
  }
  return elt;
};

// private variables - by convention, names start with underscore
$$._elementCache = {};
$$._cacheSize = 0;

// public method
$$.cacheLength = function(){
  assertTripleEqual(this, $$, "'this' refers to the parent object, $$");

  return this._cacheSize;
};


assertDeepEqual($$._elementCache, {}, "private variable '_elementCache' is accessible");
assertTripleEqual($$._cacheSize, 0, "private variable '_cacheSize' is accessible");
assertTripleEqual($$.cacheLength(), 0, "cache should be empty to start");

var elt = $$('#myDiv');

assertTripleEqual($$.cacheLength(), 1, "cache should be incremented after query");

var sameElt = $$('#myDiv');

assertTripleEqual($$.cacheLength(), 1, "cache should be not be incremented for a repeated query");
</pre>
		</dd>
	
		<dt>module.js</dt>
		<dd>
			<pre>// Fake jQuery
// Usage:
//   $$('#mySelector') // element
//   $$.cacheLength() // int (number of selectors in cache)

var $$ = (function(){
  // private variables
  var elementCache = {},
    cacheSize = 0;

  var base = function(selector){
    // check if it's already cached
    var elt = elementCache[selector];
    if (!elt){
      elt = 'fakeElement'; // we would actually use document.getElementById(), etc.
      elementCache[selector] = elt; // cache it
      cacheSize++;
    }
    return elt;
  };

  base.cacheLength = function(){
    return cacheSize;
  };

  // return public API as a function/object
  return base;
})();


assertTripleEqual($$.elementCache, undefined, "private variables should be undefined");
assertTripleEqual($$.cacheLength(), 0, "cache should be empty to start");

var elt = $$('#myDiv');

assertTripleEqual($$.cacheLength(), 1, "cache should be incremented after query");

var sameElt = $$('#myDiv');

assertTripleEqual($$.cacheLength(), 1, "cache should be not be incremented for a repeated query");
</pre>
		</dd>
	
		<dt>class_vs_instance_methods.js</dt>
		<dd>
			<pre>var Person = function(first, last){
  this.first = first;
  this.last = last;
};

// instance method
Person.prototype.fullName = function(){
  return this.first + ' ' + this.last;
};

// 'class' method
Person.newKid = function(first, parent1, parent2){
  var last = parent1.last + '-' + parent2.last;
  return new Person(first, last);
};


var jane = new Person('Jane', 'Gordon');
var dennis = new Person('Dennis', 'Levitt');

assertTripleEqual(jane.newKid, undefined, "class method isn't available on an instance");
assertTripleEqual(Person.fullName, undefined, "instance method isn't available on the class");

var joseph = Person.newKid('Joseph', jane, dennis);

assertTripleEqual(joseph instanceof Person, true, "the factory method returns a new instance");
assertTripleEqual(joseph.fullName(), 'Joseph Gordon-Levitt', "assigns the name correctly");
</pre>
		</dd>
	
		<dt>hoisting.js</dt>
		<dd>
			<pre>var isFooDefined;
try {
  console.log(foo);
  isFooDefined = true;
} catch(e){
  isFooDefined = false;
}

assertTripleEqual(isFooDefined, false, "non-declared variables will throw errors when called");
assertTripleEqual(typeof foo, 'undefined', "non-declared variables have a typeof 'undefined'");

assertTripleEqual(bar, undefined, "variable declarations get hoisted, but not the assignment");
assertTripleEqual(typeof bar, 'undefined', "declared (but unset) variables *also* have typeof 'undefined'");

var bar = 'bar';


var isBazDefined;
try {
  console.log(baz);
  isBazDefined = true;
} catch(e){
  isBazDefined = false;
}

assertTripleEqual(isBazDefined, false, "hoisting only occurs within a single scope");

function testFunc(){
  var baz = 'baz';
}
</pre>
		</dd>
	

</dl>


</body></html>
